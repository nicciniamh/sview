#!/usr/bin/env python3
"""
This program presents the user with a treeview of each systemctl 
unit with checkboxes to change their states. Unit names are searchable
with partial name matches.
"""
import os
import sys
import textwrap
import subprocess
import inspect
import argparse
import re
from pystemd.systemd1 import Unit, Manager
import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, GdkPixbuf

debug_flag = False

def set_css(widget, classname, css_data):
        """
        this function takes an arbitrary widget and applies the classname as it's class
        the css_data is applied to the widget.
        """
        if type(css_data) is str:
                css_data = bytes(css_data.encode('ascii'))
        if type(css_data) is not bytes:
                raise TypeError(f'{type(css_data)} is not appropriate for css_data')
        css_provider = Gtk.CssProvider()
        css_provider.load_from_data(css_data)
        context = widget.get_style_context()
        context.add_class(classname)
        context.add_provider(css_provider,Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)

def get_units(filter=None):
	"""
	Returns a dictionary of unit information, keyed on the unit name.
	"""
	m = Manager()
	m.load()
	units = {}
	for u in m.ListUnits():
		ustr = u[0].decode('utf-8')
		if filter:
			if filter.startswith('+'):
				if not filter[1:].lower() in ustr.lower():
					continue
			elif filter.startswith('-'):
				if filter[1:].lower() in ustr.lower():
					continue
			else:
				if not filter.lower() in ustr.lower():
					continue

		ud = {}
		ud['unit'] = '\n'.join(textwrap.wrap(u[0].decode('utf-8'), 40))
		ud['description'] = '\n'.join(textwrap.wrap(u[1].decode('utf-8'), 40))
		ud['loaded'] = (u[2].decode('utf-8').lower() == 'loaded')
		ud['active'] = (u[3].decode('utf-8').lower() == 'active')
		ud['running'] = (u[4].decode('utf-8').lower() == 'running')
		ud['file'] = u[6]
		units[ud['unit']] = ud

	return units

class ServiceViewer(Gtk.Window):
	def __init__(self):
		"""
		ServiceViewer subclasses Gtk.Window. 
		__init__ calls load_tree_view to load up all the systemctl units.
		When searches are performed the lists, search_results and 
		search_buttons are populated. search_buttons are the widgets for
		search previous, search next and close search. When close search is
		clicekd all of these are removed from the buttonbox. 
		"""
		Gtk.Window.__init__(self, title="Systemd Unit Viewer")
		self.connect('destroy', Gtk.main_quit)
		icon_theme = Gtk.IconTheme.get_default()
		try:
			pixbuf = icon_theme.load_icon('text-x-systemd-unit', 64, 0)
		except:
			pixbuf = icon_theme.load_icon('applications-system', 64, 0)
		self.set_icon(pixbuf)
		self.grid = None
		self.search_buttons = []
		self.search_results = []
		self.search_index = 0
		self.set_size_request(1280, 600)
		self.filter = None

		set_css(self,'sview','.sview {margin: 10px}')
		self.load_tree_view()

		message=["Changing systemctl unit settings may make your system unstable.",
		   "Do so at your own peril!"]

		MessageDialog(
			parent=self,
			title="Warning",
			icon='dialog-warning',
			buttons=['Cancel','Continue'],
			callback=self.on_button_clicked, 
			message = message)
		

	def on_button_clicked(self,button):
		if button.lower() == 'cancel':
			self.destroy()
			Gtk.main_quit()

	def get_buttons(self, buttondef):
		"""
		Return a Gtk.ButtonBox populated with the elements of buttondef
		which is a list of tuples of button label and button action 
		which is called when the button is clicked.
		"""
		self.button_box = buttons = Gtk.ButtonBox(orientation=Gtk.Orientation.HORIZONTAL)
		buttons.set_layout(Gtk.ButtonBoxStyle.START)

		for label, action in buttondef:
			button = Gtk.Button(label=label)
			button.connect('clicked', action)
			buttons.pack_start(button, False, False, 0)
		return buttons

	def load_tree_view(self,widget=None, filter=None, *args):
		"""
		load_tree_view loads up the treeview widget, and a buttonbox
		the treeview and buttonboxes are recreated when this method 
		is called which will be done by the 'reload units' button. 
		the treeview and buttonbox are attached to a Gtk.Grid which
		is added to the main window. If self.grid is not None,
		self.grid is removed from self and all the widgets are 
		recreated.
		"""
		if filter:
			self.filter = filter
		self.units = get_units(self.filter)
		buttons = self.get_buttons([
				('Close', Gtk.main_quit), 
				('Reload', self.load_tree_view),
				('Filter',self.filter_units),
				('Reset Filter',self.reset_filter),
				('Search', self.on_search_clicked)
			])
		if self.grid:
			self.remove(self.grid)
		self.grid = Gtk.Grid()
		self.storelist = []
		self.scrolled_window = Gtk.ScrolledWindow()
		self.grid.attach(self.scrolled_window, 0, 0, 1, 1)
		self.grid.attach(buttons, 0, 1, 1, 1)
		self.store = Gtk.ListStore(str, str, bool, bool)
		for unit, ud in self.units.items():
			items = [unit, ud['description'], ud['active'], ud['running']]
			self.store.append(items)
			items.append(ud['file'])
			self.storelist.append(items)

		self.tree_view = Gtk.TreeView(model=self.store)

		# Text columns
		for i, column_title in enumerate(["Unit", "Description"]):
			renderer = Gtk.CellRendererText()
			column = Gtk.TreeViewColumn(column_title, renderer, text=i)
			column.set_expand(True)
			self.tree_view.append_column(column)
			# Make columns sortable
			column.set_sort_column_id(i)

		# Toggle columns
		for i, column_title in enumerate(["Active", "Running"], start=2):
			renderer = Gtk.CellRendererToggle()
			renderer.set_alignment(0.5, 0.5)
			renderer.connect("toggled", self.on_cell_toggled, (i, column_title))
			column = Gtk.TreeViewColumn(column_title, renderer, active=i)
			column.set_expand(True)
			column.set_alignment(0.5)
			self.tree_view.append_column(column)
			# Make columns sortable
			column.set_sort_column_id(i)

		self.scrolled_window.add(self.tree_view)
		self.scrolled_window.set_vexpand(True)
		self.scrolled_window.set_hexpand(True)

		self.add(self.grid)
		if len(self.search_results):
			self.open_search()

		self.show_all()

	def reset_filter(self,*args):
		self.filter = None
		self.load_tree_view()

	def filter_units(self,*args):
		def do_filter(filter):
			self.load_tree_view(None,filter)
		FilterDialog(parent=self,callback=do_filter)

	def on_cell_toggled(self, widget, path, user_data):
		"""
		this method is called when one of the checkboxes in the 
		treeview is clicked. From the element and the row 
		we determine what commands to issue to systemctyl
		"""
		i = int(path)
		index = Gtk.TreePath.new_from_string(path).get_indices()[0]
		column, column_title = user_data
		state = self.store[i][column] = not self.store[i][column]
		unit = self.store[i][0]
		self.set_service_state(unit, column_title, state)

	def set_service_state(self, unit, item, state):
		"""
		This is where we call systemd to manipulate units based on item and state.
		"""
		debug(unit, item, state)

		if item == 'Running':
			if state:
				self.run_systemctl_command('start', unit)
			else:
				self.run_systemctl_command('stop', unit)
		elif item == 'Active':
			if state:
				self.run_systemctl_command('enable', unit)
			else:
				self.run_systemctl_command('disable', unit)
		else:
			raise IndexError(f'Invalid item {item}')

	def run_systemctl_command(self, *args):
		# Command to run the privileged script with pkexec
		command = ["pkexec", "/bin/systemctl", *args]

		# Run the command
		try:
			result = subprocess.run(command, capture_output=True, text=True)
			if result.returncode == 0:
				print("Privileged task completed successfully", result.stdout)
			else:
				MessageDialog(parent=self, title="subprocess Error, systemctl returned non-zero", message=result.stderr,icon="dialog-error")
		except Exception as e:
			MessageDialog(parent=self, title=f"Exception calling systemctl", message=f"{e}\r{result.stderr}", icon="dialog-error")


	def search_and_select(self, search_text):
		"""
		collect a list of paths that match the search term, populate
		the search_results and set search_index to 0. This allows for 
		searching within multile results. 
		If no search results are found, report it in a dialog and stop
		otherwise, call open_search to set up the search buttons. 
		"""
		self.search_results = []
		self.search_index = 0
		for row in self.store:
			if search_text.lower() in row[0].lower():
				path = self.store.get_path(row.iter)
				self.search_results.append(path)

		if len(self.search_results):
			search_index = -1
			self.open_search()
			self.search_next()
			return  True
		return False

	def open_search(self,*args):
		"""
		open_search creates the additional search buttons in the button_box
		"""
		self.search_buttons = []
		for label, action in [('Search Previous',self.search_prev),('Search Next',self.search_next),('Close Search',self.close_search)]:
			button = Gtk.Button(label=label)
			button.connect('clicked',action)
			self.search_buttons.append(button)
			self.button_box.pack_start(button,True,True,0)
			self.button_box.show_all()

	def close_search(self,*args):
		"""
		close_search removes the additional search buttons from the button_box
		resets search_results and search_buttons to an empty list. 
		"""
		for button in self.search_buttons:
			self.button_box.remove(button)
		self.search_buttons = []
		self.search_results = []
		self.search_index = 0

	def search_next(self,*args):
		"""
		Increment search index and select the next path in the list
		"""
		if not len(self.search_results):
			return
		self.search_index += 1
		if self.search_index >= len(self.search_results):
			self.search_index = 0
		path = self.search_results[self.search_index]

		self.tree_view.scroll_to_cell(path)
		self.tree_view.set_cursor(path)
		

	def search_prev(self,*args):
		"""
		decrement search index and select the previous path in the list
		"""
		if not len(self.search_results):
			return
		self.search_index -= 1
		if self.search_index < 0:
			self.search_index = len(self.search_results) -1
		path = self.search_results[self.search_index]
	
		self.tree_view.scroll_to_cell(path)
		self.tree_view.set_cursor(path)


	def on_search_clicked(self, button):
		"""
		Handle search button click, show an input dialog to get search text.
		"""
		self.close_search()
		QueryDialog(
			title="Search for units",
			message="Enter a full or parital unit name",
			parent=self,
			prompt="Search term",
			callback=self.search_text_in)

	def search_text_in(self,search_text):
		if search_text:
			if not self.search_and_select(search_text):
				MessageDialog(parent=self,title='No results',message=f'The term, "{search_text}" was not found.')

class MessageDialog(Gtk.Window):
	"""
	MessageDialog 
	kwargs: 
		parent - parent to be modal for, none for not modal
		title - window title
		icon - gtk icon name 
		message - text to display
		buttons - list of strs to make buttons with
		callback - callback for when button is clicked, callback is called with str for button

	"""
	def __init__(self,**kwargs):
		self.button_clicked = None
		parent = kwargs.get('parent',None)
		title = kwargs.get('title','dialog')
		message = kwargs.get('message','no message')
		if type(message) is list:
			message = '\n'.join(message)
		icon = kwargs.get('icon','dialog-info')
		buttons = kwargs.get('buttons',['Ok'])
		self.callback = kwargs.get('callback',None)
		super().__init__(title=title)
		if parent:
			self.set_transient_for(parent)
		grid = Gtk.Grid()
		mlabel = Gtk.Label()
		mlabel.set_text(message)
		mlabel.set_hexpand(True)
		mlabel.set_vexpand(True)
		set_css(mlabel,'mlabel','.mlabel {font-weight: bold; margin: 10px; padding: 10px;}')
		icon = Gtk.Image.new_from_icon_name(icon, Gtk.IconSize.DIALOG)
		titlebar = Gtk.HeaderBar()
		titlebar.set_title(title)
		self.set_titlebar(titlebar)
		row = 0
		grid.attach(icon,	0, row,1,1)
		grid.attach(mlabel,	1, row,4,1)
		row += 1
		for i in range(0,len(buttons)):
			button = Gtk.Button(label=buttons[i])
			button.connect('clicked',self.button_handler,buttons[i].lower())
			grid.attach(button,i,row,1,1)
		self.add(grid)
		self.grid = grid
		self.show_all()
		
	def button_handler(self,widget,button):
		debug('message_dialog',button,self.callback)
		self.button_clicked = button
		if self.callback:
			self.callback(button)
		self.destroy()

class QueryDialog(MessageDialog):
	def __init__(self, **kwargs):
		prompt = kwargs.get('prompt','Entry')
		self.complete_callback = kwargs.get('callback')
		title = kwargs.get('title','Query')
		kw = dict(kwargs)
		kw['title'] = title
		kw['icon'] = 'dialog-question'
		kw['callback'] = self.on_button
		kw['buttons'] = ['Ok','Cancel']
		super().__init__(**kw)
		row = 1
		self.grid.insert_row(row)
		elabel = Gtk.Label(label=prompt)
		set_css(elabel,'elabel','.mlabel {font-weight: bold; margin: 10px; padding: 10px;}')
		self.grid.attach(elabel,0,row,1,1)
		self.entry = Gtk.Entry()
		self.grid.attach(self.entry,1,row,1,1)
		self.show_all()

	def on_button(self,button):
		debug('query_dialog',button,self.callback)
		if button.lower() == 'ok':
			text = self.entry.get_text().strip()
			if text:
				if self.complete_callback:
					self.complete_callback(text)
		else:
			text = None
		
	

class FilterDialog(QueryDialog):
	def __init__(self,**kwargs):
		self.complete_callback = kwargs.get('callback',None)
		kw = dict(kwargs)
		kw['prompt'] = 'Filter Text'
		kw['title'] = 'Filter Units'
		kw['message'] = 'Filter units by full or partial\nname in or out of list'
		super().__init__(**kw)
		self.callback = self.on_button
		self.iflag = ''
		toggle = Gtk.ToggleButton(label='Include Units')
		toggle.connect('toggled',self.on_toggle)
		row = 2
		self.grid.insert_row(row)
		self.grid.attach(toggle,1,row,1,1)
		self.show_all()

	def on_toggle(self,widget):
		if widget.get_active():
			self.iflag = '+'
			widget.set_label('Include Units')
		else:
			self.iflag = '-'
			widget.set_label('Exclude Units')


	def on_button(self,button):
		debug('filter_dialog',button,self.callback)
		if button.lower() == 'ok':
			text = self.entry.get_text().strip()
			if text:
				text = f'{self.iflag}{text}'
				if self.complete_callback:
					self.complete_callback(text)

class Debug:
	"""
	This class allows for the printing of debug messages. Variable arguments can be 
	passed to join multiple strings. 
	Debug messages are printed with some color highlighting and short call history..
	"""
	def __init__(self, debug_flag):
		self.debug_flag = debug_flag

	def set_debug(self,flag):
		self.debug_flag = flag

	def __call__(self, *args):
		"""
		print *args as debug message with caller
		"""
		if self.debug_flag:
			frames = inspect.stack()
			grandcaller = frames[3] if len(frames) >= 4 else None
			gc = '~none~'
			if grandcaller:
				grandcaller_file = os.path.basename(grandcaller.filename)
				grandcaller_line = grandcaller.lineno
				grandcaller_function = grandcaller.function
				gc = f"{grandcaller_file}:{grandcaller_line} {grandcaller_function}"

			frame = inspect.getouterframes(inspect.currentframe(), 2)[1]
			caller = frame[3]
			file = os.path.basename(frame[1])
			line = frame[2]
			cs = f'{file}:{line} {caller}'

			caller_text = f'{gc}->{cs}'
			tag = '\x1b[1;34;40mDEBUG\x1b[0m'
			print(f'{tag} - \033[1;36;40m{caller_text}\033[0m :\033[1;37;40m', *args, '\033[0m', file=sys.stderr)

license = """

Use of this program implies consent with the following license.

MIT License

Copyright (c) 2024 Nicole Stevens

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""

if __name__ == "__main__":
	parser = argparse.ArgumentParser(
		description='Systemd Unit Viewer',
		epilog="Copyright © Nicole Stevens"
	)
	parser.add_argument('-d', '--debug', action='store_true', default=False, help='Enable debug messages')
	parser.add_argument('--license', action='store_true', default=False, help='Show license')
	args = parser.parse_args()
	if args.license:
		print(license)
		sys.exit(1)
	debug = Debug(args.debug)
	if args.debug:
		debug("Debug messages enabled")
	s = ServiceViewer()
	Gtk.main()
